# 如何保证服务程序永不停机

## 生成测试数据

本项目主要用两种数据来测试

- 全国气象站点参数   **存放在文本文件中**
- 全国气象分钟观测数组   站点每分钟进行一次观测，每观测一次产生一行数据  **观测数据也存放在文本文件中**（为模拟数据）

### 业务要求

- 根据全国气象站点参数，模拟生成观测数据
- 程序每分钟运行一次，每次生成839行数据，存放在一个文件中；

### 四个步骤

- 搭建程序框架（运行的参数，说明文档，运行日志）。
- 把全国气象站点参数文件加载到站点参数容器中。
- 遍历站点参数容器，生成每个站点的观测数据，存放在站点观测数据容器中。
- 把站点观测数据容器中的记录写入文件  支持csv，xml和json

#### 搭建程序框架（运行的参数，说明文档，运行日志）。

**这个程序需要三个参数** 

- 全国气象战点参数文件:inifile 

- 生成的测试数据存放的目录:outpath

- 程序运行的日志:logfile

主要任务

- 加上可执行文件，所以命令行参数一共要四个，所以**argc == 4**，否则就给用户提示并退出程序。

- 为服务程序增加上运行日志，写日志文件

  ```c++
  //打开日志文件函数
  //filename：日志文件名，建议采用绝对路径打开，如果文件名中的目录不存在，就会先创建目录
  //openname：日志文件的打开方式，与fopen库函数打开文件的方式相同，缺省值是‘a+’
  //bBackup：是否自动切换，true-切换，false-不切换，在多进程的服务程序中，如果多个进程公用一个日志文件，bBackup必须为false。
  //bEnBuffer：是否启用文件缓冲机制，true-启用，false-不启用，如果启用缓冲区，那么写进日志文件中的内容不会立即写入文件，缺省是不启用。
  bool Open(const char* filename,const char* openmode=0,bool bBackup=true,bool bEnBuffer=false);
  
  //把内容写进日志文件，fmt是可变参数，使用方法与printf库函数相同。
  //Write方法会写入当前的时间，WriteEx方法不写时间
  bool Write(const char* fmt,...);
  ```

  

#### 把全国气象站点参数文件加载到站点参数容器中。

此步骤主要涉及将文件中的数据读入并放到一个容器中，其中还涉及

**把站点参数文件中的数据加载到容器中，主要有以下步骤：**

```c++
//打开站点参数文件

while(1)
{
    //从站点参数文件中读取一行，如果已经读取完，就跳出循环   
    
    //把读取到的一行拆分  用到框架中的字符串相关处理的类
    
    //把站点参数的每个数据项保存到站点参数结构体中
    
    //把站点参数结构体放入站点参数容器
}
```

**上述过程主要需要程序框架中的文件操作相关的函数，主要的相关函数为：**

```c++
/*C语言的文件操作需要一个文件指针*/

//打开文件
//filename:代打开文件名，建议采用绝对路径打开
//openmode:打开文件的模式，与fopen库函数的打开模式相同
//bEnBuffer:是否启用缓冲，true-启用  false-不启用
//注意：如果待打开文件的目录不存在，就会创建目录。
bool Open(const char *filename,const char *openmode,bool bEnBuffer=true);

//从文件中读取以换行符“\n”结束的一行，类似于fgets函数
//buffer:用于存放读取的内容，buffer必须大于readsize+1，否则可能会造成内存溢出
//readsize:本次打算读取的字节数，如果已经读取到了结束标志"\n",函数返回
//bdelcrt:是否删除行结束标志"\r"和"\n"，true-删除，false-不删除，缺省值是false
//返回值:true-成功，false-失败，一般情况下，失败可以认为是文件已经结束
bool Fgets(char *buffer,const int readsize,bool bdelcrt=false);

/*注意：文件指针的本质是动态分配的内存空间，使用完需要释放*/
```

**与字符串相关的操作的类：**

```c++
//XXmdStr类用于拆分有分隔符的字符串
vector<string> m_vCmdStr;//存放拆分后的字段内容

// 把字符串拆分到m_vCmdStr容器中
// buffer：待拆分字符串
// sepstr：buffer中采用的分隔符，注意，sepstr参数的数据类型不是字符，是字符串
// bdelspace：拆分后是否删除字段内容前后的空格，true-删除，false-不删除。缺省为哦不删除
void SplitToCmd(const string &buffer,const char *sepstr,const bool bdelspace=false);

//获取拆分后字段的个数，即m_vCmdStr容器的大小
int CmdCount();

// 从m_vCmdStr容器获取字段内容
// inum：字段的顺序号，类似数组的下标
// value：传入变量的地址，用于存放字段的内容
// 返回值：true-成功，如果inum的取址超过了m_vCmdStr容器的大小，返回失败
// 有多种重载，此处只列出几个
bool GetValue(const int inum,char *value,const int ilen=0);//字符串，ilen缺省值为0
bool GetValue(cosnt int inum,int *value)
```

#### 遍历站点参数容器，生成每个站点的观测数据，存放在站点观测数据容器中。

**存放模拟生成数据的结构体：**

 ```c++
 // 全国气象站点分钟观测数据结构
 struct st_surfdata
 {
   char obtid[11];	// 站点代码
   char ddatetime[21];	// 数据时间：格式yyyymmddhh24miss
   int t;		// 气温：单位，0.1摄氏度
   int p;		// 气压：0.1百帕
   int u;		// 相对湿度，0-100之间的值
   int wd;		// 风向，0-360之间的值
   int wf;		// 风俗，单位0.1m/s
   int r;		// 降雨量：0.1mm
   int vis;		// 能见度：0.1米
 };
 vector<struct st_surfdata> vsurfdata;  // 存放全国气象站点分钟观测数据 
 ```

**主要实现的函数：**

```c++
// 模拟生成全国气象站点分钟观测数据，存放在vsurfdata容器中
void CrtSurfData()
{
    // 播随机数种子（模拟数据要使用随机数）
    
    // 获取当前时间，当成观测时间
    
    // 遍历气象站点参数vscode容器，结合模拟生成的数据，充当每个站点生成的观测数据
    for(int ii = 0; ii < vstcode.size(); ii++)
    {
        // 用随机数填充分钟观测数据的结构体
        
        // 把观测数据的结构体放入相应的容器中（vsurfdata）
    }
}
```

#### 把站点观测数据容器中的记录写入文件

**错误的写文件方法：**

此方法存在漏洞，若在程序正在写文件的过程中，有另一个程序要读这个文件，那么他就会读到不完整的信息

1. 创建文件
2. 往文件中写入数据
3. 关闭文件

**正确的写文件方法：**

可避免在文件写入数据的过程中被读取

1. 创建临时文件
2. 往临时文件中写入数据
3. 关闭临时文件
4. 把临时文件改名为正式的文件。

#### 生成csv文件

```c++
// 把容器vsurfdata中的全国气象站点分钟观测数据写入文件
bool CrtSurfFile(const char *outpath,const char *datafmt)
{
  CFile File;

  // 拼接生成数据的文件名，例如：SURF_ZH_20210629092200_2254.csv
  char strFileName[301];
    
  // sprintf与printf类似，printf打印到命令行，sprintf打印到第一个参数中（一个字符串）
  sprintf(strFileName,"%s/SURF_ZH_%s_%d.%s",outpath,strddatetime,getpid(),datafmt);
  // 打开文件
  if (File.OpenForRename(strFileName,"w")==false)// 起一个临时文件的名字打开文件
  {
    logfile.Write("File.OpenForRename(%s) failed.\n",strFileName);
    return false;
  }
    
  // 写入第一行的标题（增加数据文件的可读性）
  // int strcmp(const char *s1,const char *s2)
  // strcmp:字符串比较 返回值小于0，表示s1小于s2
  // 返回值大于0，表示s1大于s2
  // 返回值等于0，表示两个字符串相等
  if (strcmp(datafmt,"csv")==0) File.Fprintf("站点代码，数据时间，气温，气压，相对湿度，风向，风速，降雨量，能见度\n");
  // 遍历存放观测数据的vsurfdata容器
  for(int ii = 0; ii < vsurfdata.size(); ii++)
  {
    // 写入一条记录
    if (strcmp(datafmt,"csv")==0)
    {
      File.Fprintf("%s,%s,%.1f,%.1f,%d,%d,%.1f,%.1f,%.1f\n",vsurfdata[ii].obtid,vsurfdata[ii].ddatetime,vsurfdata[ii].t/10.0,vsurfdata[ii].p/10.0,vsurfdata[ii].u,vsurfdata[ii].wd,vsurfdata[ii].wf/10.0,vsurfdata[ii].r/10.0,vsurfdata[ii].vis/10.0);
    }
  }

  // 关闭文件
  File.CloseAndRename(); // 关闭文件 并恢复为原来的名字

  logfile.Write("生成数据文件%s成功，数据时间%s，记录数%d。\n",strFileName,strddatetime,vsurfdata.size());

  return true;

}
```

**生成xml文件和json文件与生成csv文件过程类似**

## Linux信号

#### 信号的基本概念

信号(signal)是软件中断，是进程之间相互传递消息的一种方法，用于通知进程发生了什么事件，但是，不能给进程传递任何数据。

信号产生的原因有很多，在Liunx下，可以用kill和killall命令发送信号。

**kill通过进程号来发送信号 **

```
kill -信号代码 进程id
// 一般通过ps命令来查找进程号
ps -ef|grep 进程名
```

**killall通过进程命来传递信号而不是进程id**

```c++
killall -信号代码 进程名
```

**其中信号代码一共有64种，可以使用 kill -l查看**

#### 信号的类型(常用)

| 信号量  | 信号值 | 默认处理动作 | 发出信号的原因                                 |
| ------- | ------ | ------------ | ---------------------------------------------- |
| SIGINT  | 2      | A            | 键盘中断 Ctrl+c                                |
| SIGKILL | 9      | AEF          | 采用kill -9 进程编号 强制杀死程序              |
| SIGALRM | 14     | A            | 由alarm(2)发出的信号                           |
| SIGTERM | 15     | A            | 采用 "kill 进程号" 或 "killall 程序名"通知程序 |
| SIGUSR1 | 10     | A            | 用户自定义信号1                                |
| SIGUSR2 | 12     | A            | 用户自定义信号2                                |
| SIGCHLD | 17     | B            | 子进程结束信号                                 |

- A: 缺省的动作是终止程序
- B：缺省的动作是忽略此信号，将该信号丢弃，不做处理
- C：缺省的动作是终止进程并进行内核映像转储(core dump)，内核映像转储是指将进程数据在内存的映像和进程在内核结构中的部分内容以一定格式转储到文件系统，并且进程退出执行，这样做的好处是为程序员提供了方便，使得他们可以得到进程当前执行时的数据值，允许他们确定转储的原因，并且可以调试他们的程序。
- D：缺省的动作是停止程序，进入停止状态的程序还能重新继续，一般是在调试的过程中
- E：信号不能被捕获
- F：信号不能被忽略

#### 信号的处理

进程对信号的处理方法有三种：

- 对该信号的处理采用系统的默认操作，大部分的信号的默认操作是终止进程
- 设置中断处理的函数，收到信号后，由该函数来处理
- 忽略某个信号，对该信号不做任何处理，就像未发生过一样。

**signal函数可以设置程序对信号的处理方式**

```c++
// 函数声明
sighandler_t signal(int signum,sighandler_t handler);
/*
参数signum表示信号的编号
参数handler表示信号的处理方式，有三种情况：
1).SIG_DFL：恢复参数signum所指信号的处理方法为默认值
2).一个自定义的处理信号的函数，信号的编号为这个自定义函数的参数
3).SIG_IGN：忽略参数signum所指的信号

```

#### 信号有什么用

服务程序运行在后台，如果想要中止它，杀掉不是个好办法，因为程序被杀死的时候，程序突然死亡，没有安排善后工作。

如果向服务程序发送一个信号，服务程序收到这个信号后，调用一个函数，在函数中编写善后的代码，程序就可以有计划的退出。

向服务程序发送0的信号，可以检测程序是否存活。

## Linux多进程

#### Linux的0，1，2号进程

- 0：idel进程，系统创建的第一个进程，加载系统
- 1：systemd进程，系统初始化，是所有其它用户进程的祖先
- 2：kthreadd进程，负责所有内核线程的调度和管理

#### 进程的表示

- 每个进程都有一个非负整数表示的唯一进程ID
- 查看进程：ps -ef|grep 进程名

#### 进程表示

- getpid(void)，获取进程ID
- getppid(void)，获取父进程ID

```c++
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>

int main()
{
    printf("getpid()=%d\n",getpid()); // 查看本程序的进程id
    printf("getppid()=%d\n",getppid()); // 查看本进程的父进程的id
    
    sleep(50);
}
```

#### fork函数

- 一个现有的进程调用函数fork创建一个新的进程。
- 子进程和父进程继续执行fork函数后的代码
- fork函数调用一次，返回两次
- 调用fork函数，子进程返回0，父进程返回子进程的进程id。
- 子进程是父进程的副本
- 子进程获得了父进程的数据空间、堆和栈的副本，不是共享。（不相互影响，相当于在复印件上进行操作）
- 父进程中打开的文件描述符也被复制到子进程中

```c++
int main()
{
    FILE *fp=fopen("/tmp/tmp.txt","w+");
    fprintf(fp,"111哈哈哈哈");
    // 由于第一次写的内容太短，会先存进缓冲区
    // 而fork之后子进程也会复制父进程的副本，缓冲区的内容也会跟着复制过去
    // 导致最终向文件中写入两次"111哈哈哈哈"
    // 解决方法：在fork之前刷新一次缓冲区，将缓冲区的内容写进去
    // fflush(fp);
    int pid = fork();
    
    if(pid==0)
    {
        printf("这是子进程，将要执行之进程的任务");
        fprintf(fp,"aaa 哈哈哈哈");
    }
    
    if(pid>0)
    {
        printf("这是父进程，将要执行父进程的任务");
        fprintf(fp,"bbb 哈哈哈哈");
    }
    fclose(fp); // 关闭文件
    // 在子进程中关闭文件，不会影响父进程
    // 返回来也同样成立
}
```

- 如果父进程先退出，子进程会称为孤儿进程(没有影响)，被一号进程所接收

- 如果子进程先退出，内核向父进程发送SIGCHLD信号，如果父进程不处理这个信号，子进程会成为僵尸进程。

  **如果子进程在父进程之前终止，内核为每个子进程保留了一个数据结构，包括进程编号，终止状态和使用cpu时间等，父进程如果处理了子进程退出的信息，内核就会释放这个数据结构，如果父进程没有处理子进程退出的信息，内核就不会释放这个数据结构，子进程进程编号就会一直被占用，但是系统可用的进程编号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，这就是僵尸进程的危害。**

  **僵尸进程的处理方式**

  - signal(SIGCHILD,SIG_IGN); // 在父进程中直接忽略这个信号，忽略也是处理了这个信号

  - 在父进程中增加等待子进程退出的代码

    ```c++
    int sts; wait(&sts); // wait这个函数可以等待子进程的退出
    /*
     *1、wait函数有三个功能：
     *  阻塞等待子进程退出
     *  回收子进程残留资源
     *  获取子进程结束状态(退出原因)
     *
     */
    ```
  
  - 设置SIGCHLD信号的处理函数，在信号处理函数中调用wait
  
    ```c++
    void func(int sig)
    {
        int sts;
        wait(&sts);
    }
    int main()
    {
        signal(SIGCHLD,func);
    }
    ```

## 服务程序的调度

**服务程序的调度需求**

- 周期性的启动后台服务程序
- 常驻内存中的服务程序异常中止，在短时间内重启。

**在C语言中通过调用exec系列函数来实现调用其他程序，常用的为execl()和execv()**

```c++
int main()
{
    execl("/usr/bin/ls","/usr/bin/ls","-lt","/tmp",(char*)0); // 调用ls 
}
```



**exec是用参数中指定程序替换了当前进程的正文段，数据段，堆和栈**

**把当前进程替换为新的进程**

```c++
int main()
{
    printf("aaa\n");
    execl("/usr/bin/ls","/usr/bin/ls","-lt","/tmp",(char*)0); // 调用ls 
	printf("bbb\n");
    /*
    * 只会输出aaa和tmp目录下的内容，不会输出bbb
    */
}
```

**在C语言中，可以先执行fork函数，创建一个子进程，让子进程调用execl执行新的程序，新程序将替换子进程，不会影响父进程，在父进程中，可以调用wait函数等待新程序运行的结果，这样就可以实现调度的功能。**

```c++
while(1)
{
    if(fork()==0) // 子进程所要执行的
    {
        execl("/usr/bin/ls","/usr/bin/ls","-lt","/tmp",(char*)0); // 替换子进程，不会影响父进程
    }
    else // 父进程所要执行的
    {
        int status;
        wait(&status);
        sleep(10); // 十秒调用一次
    }
}
/*采用这种方式时需要注意，当子程序调用execl失败的时候，要及时的退出程序，方式无效的死循环，使服务器挂掉*/
```

## Linux共享内存

**查看共享内存的方法：ipcs -m**

- Linux共享内存的基础知识和使用方法
- Linux信号量的基础知识和使用方法
- 开发守护进程模块，与调度模块结合，保证服务程序永不停机

Linux中每个进程的内存是独立的，不能相互访问的。当进程之间需要交换数据或者进行交流的时候，就要用到共享内存。

**共享内存：**就是允许多个进程访问同一个内存空间，是在多个进程之间共享和传递数据最高效的方式。操作系统将不同进程之间共享内存安排为同一段物理内存，进程可以将共享内存连接到它们自己的地址空间中，如果某个进程修改了共享内存中的数据，其他进程读到的数据也将会改变。

**共享内存并未提供锁机制，也就是说，在某一个进程对共享内存进行读写的时候，不会阻止其他的进程对它读写。如果要对共享内存的读写加锁，可以使用信号量**

共享内存的操作只有四个动作：

- 调用shmget函数获取或者创建共享内存  int shmget(key_t key,size_t size,int shmflg)

  与信号量一样，程序需要提供一个参数key，它有效地为共享内存段命名，shmget函数返回一个共享内存标识符，该标识符用于后续的共享内存函数。

  第二个参数size以字节为单位指定需要的共享的内存容量。

  第三个参数shmflg包含9个比特的权限标志，它们的作用与创建文件时使用的mode标志一样。

  如果共享内存创建成功，shmget返回一个非负整数，即共享内存标识符，否则，失败返回-1.

- 调用shmat函数把共享内存连接到当前进程的地址空间  void* shmat(int shmid,const void* shmaddr,int shmflg)

  第一次创建共享内存时，它不能被任何进程访问。要想启用对该内存的访问，必须将其连接到一个进程的地址空间中。

  第一个参数shmid是由shmget返回的共享内存标识符

  第二个参数shmaddr指定的是共享内存连接到当前进程中的地址位置。它通常是一个空指针，表示让系统来选择共享内存出现的地址

  第三个参数shmflg是一组位标志。它的两个可能取值是SHM_RND(这个标志与shm_addr联合使用，用来控制共享内存连接的地址)和SHM_RDONLY(它使得连接的内存只读)。我们很少需要控制共享内存连接的地址，通常都是让系统来选择一个地址，否则就会使应用程序对硬件的依赖性过高。

  如果shmat调用成功，它返回一个指向共享内存第一个字节的指针；如果失败那就返回-1.

  共享内存的读写权限由它的属主(共享内存的创建者)，它的访问权限和当前进程的属主决定。

  共享内存的访问权限类似于文件的访问权限。

  这个规则的一个例外是，当shmflg & SHM_RDONLY为true时的情况，此时即使该共享内存的访问权限允许写操作，它都不能被写入。

- 调用shmdt函数把共享内存从当前进程中分离  int shmdt(const void* shmaddr);

  shmdt函数的作用是将共享内存从当前进程中分离。它的参数是shmat返回的地址指针。成功时它返回0，失败时返回-1。

  注意，将共享内存分离并未删除它，只是使得该共享内存对当前进程不再可用

- 调用shmctl函数删除共享内存  int shmctl(int shmid,int cmd,struct shmid_ds *buf);

```c++
/* int shmget(key_t key,size_t size,int shmflg)
 * void* shmat(int shmid,const void* shmaddr,int shmflg)
 * int shmdt(const void* shmaddr);
 * int shmctl(int shmid,int cmd,struct shmid_ds *buf);
 */

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>
#include<sys/ipc.h>
#include<sys/shm.h>

struct st_pid
{
  int pid;
  char name[51];
};
int main(int argc,char* argv[])
{
    // 共享内存的标志
    int shmid;
    
    // 获取或创建共享内存，键值为0x5005
    if((shmid=shmget(0x5005,sizeof(struct st_pid),0640|IPC_CREAT))==-1)
    {
        printf("shmget(0x5005) failed\n");
        return -1;
    }
    
    // 把共享内存连接到当前进程的地址空间
    struct st_pid* stpid = 0;
    if ((stpid=(struct st_pid*)shmat(shmid,0,0))==(void*)-1)
    {
        printf("shmat failed\n");
        return -1;  
    }
    
    printf("pid=%d,name=%s\n",stpid->pid,stpid->name);
    stpid->pid = getpid();
    strcpy(stpid->name,argv[1]);
    printf("pid=%d,name=%s\n",stpid->pid,stpid->name);
    
    // 把共享内存从当前进程中分离
    shmdt(stpid);
    
    // 删除共享内存
    /*if(shmctl(shmid,IPC_RMID,0)==-1)
    {
        printf("shmctl failed\n");
        return -1;
    }*/
    return 0;
}
```

## Linux信号量

**使用命令 ipcs -s 查看当前的信号量**

- 信号量本质上是一个非负数的计数器
- 给共享资源建立一个标志，表示该共享资源被占用情况
- P操作(申请资源-1)，V操作(释放资源+1)

- 二值信号量是信号量的一种特殊形式，表示资源只有可用和不可用两种状态：0-不可用，1-可用

```c++
// 使用信号量需要包含的头文件
#include<sys/types.h>
#include<sys/ipc.h>
#include<sys/sem.h>

/*
 *key:一个键，程序对信号量的访问都是间接的，它先提供一个键，再由系统生成一个相应的信号量标识符。只有semget函数才直接使用信号量键，所有其他信号量函数都是使用由semget函数返回的信号量标识符
 *nsems:需要的信号量的数量。它几乎总是取值1
 *semflg:这个参数是一组标志，它低端的9个比特是该信号量的访问权限，其作用类似于文件的访问权限
 */
int semget(key_t key,int nsems,int semflg); // 调用成功返回一个正数值，它就是其他信号量函数将用到的信号量标识符，失败返回-1
// 信号量的初始化不能直接用semget(key,1,0666|IPC_CREAT),因为信号量创建后，初始值为0

/*
 *semop函数用于改变信号量的值，信号量的值不能直接进行加减操作
 *
 */
int semop(int sem_id,struct sembuf *sem_ops,size_t num_sem_ops);

/*
 *第一个参数sem_id是由semget返回的信号量的标识符。sem_num是信号量编号，当需要用到成组的信号量的
 *时候，就要用到这个参数，他一般取值为0，表示这是第一个也是唯一一个信号量。command参数是将要采取的
 *动作.如果还有第四个参数，他将会是一个union semun结构
 */
int semctl(int sem_id,int sem_num,int command,...);
```

**信号量的初始化分为三个步骤：**

- 获取信号量，如果成功，函数返回。
- 如果失败，则创建信号量。
- 设置信号量的初始值。

```c++
#include"_public.h"

CSEM sem; // 用于给共享内存加锁的信号量

struct st_pid
{
  int pid;
  char name[51];
};
int main(int argc,char* argv[])
{
    // 共享内存的标志
    int shmid;
    
    // 获取或创建共享内存，键值为0x5005
    if((shmid=shmget(0x5005,sizeof(struct st_pid),0640|IPC_CREAT))==-1)
    {
        printf("shmget(0x5005) failed\n");
        return -1;
    }
    
    // 如果信号量已存在，获取信号量，如果信号量不存在，则创建它并初始化为value
    if(sem.init(0x5006)==false)
    {
        printf("sem.init(0x5006) failed\n");
        return -1;
    }
    
    // 把共享内存连接到当前进程的地址空间
    struct st_pid* stpid = 0;
    if ((stpid=(struct st_pid*)shmat(shmid,0,0))==(void*)-1)
    {
        printf("shmat failed\n");
        return -1;  
    }
    
    printf("aaa time=%d,val=%d\n",time(0),sem.value()); // 加锁前打印当前时间和信号量的值
    sem.P(); // 加锁
    printf("bbb time=%d,val=%d\n",time(0),sem.value()); // 加锁后打印当前时间和信号量的值
    printf("pid=%d,name=%s\n",stpid->pid,stpid->name);
    stpid->pid = getpid();
    sleep(10); // 为了方便观察
    strcpy(stpid->name,argv[1]);
    printf("pid=%d,name=%s\n",stpid->pid,stpid->name);
    printf("ccc time=%d,val=%d\n",time(0),sem.value()); // 解锁前打印当前时间和信号量的值
    sem.V(); // 解锁
    printf("ddd time=%d,val=%d\n",time(0),sem.value()); // 解锁后打印当前时间和信号量的值
    
    // 把共享内存从当前进程中分离
    shmdt(stpid);
    
    // 删除共享内存
    /*if(shmctl(shmid,IPC_RMID,0)==-1)
    {
        printf("shmctl failed\n");
        return -1;
    }*/
    return 0;
}
```

## 进程的心跳机制

  设置一块共享内存用来存放进程心跳信息的结构体内容，结构体如下：

```c++
// 进程心跳信息的结构体
struct st_procinfo
{
    int pid; 		// 进程id
    char pname[51]; // 进程名称，可以为空
    int timeout; 	// 超时时间，单位：秒
    time_t atime;	// 最后一次心跳的时间
}
```

每个服务程序启动的时候会查找共享内存，找到一块没有使用的内存，将自己的心跳信息写进去，并且在程序运行的过程中还会不断的将自己的心跳信息更新进去，表示自己还存活。

守护进程每隔若干秒遍历一次共享内存，检查每个服务程序的心跳信息，如果当前时间减去最后一次心跳的时间超过了超时时间，表示服务程序已经没有心跳了(服务程序死掉)，守护进程就发出信号终止服务程序。服务程序被终止之后，调度程序会重新启动它。

```c++
/*
 *进程id是循环使用的，如果曾经有一个进程异常退出，没有清理自己的心跳信息，
 *它的进程信息将残留在共享内存中，不巧的是，当前进程重用了上述进程的id，
 *这样就会在共享内存中存在两个进程id相同的记录，守护进程检查到残留进程的心跳时，
 *会向进程id发送退出信号，这个信号将误杀当前进程
 */
```

## 守护进程

- 服务程序由调度程序启动
- 如果服务程序死机（挂起），守护进程将终止它
- 服务程序被终止后，调度程序将重新启动它。这样就能保证整个系统稳定运行

开发守护程序主要分两步骤：

- 服务程序在共享内存中维护自己的心跳信息
- 开发守护程序，检查共享内存，终止已经死机的服务程序



exit函数与析构函数

- exit函数不会调用局部对象的析构函数
- exit函数会调用全局对象的析构函数
- return会调用局部和全局对象的析构函数

## 完善生成测试数据程序

- 增加生成历史数据文件的功能，为压缩文件和清理文件模块准备历史数据文件

- 增加信号处理函数，处理2和15的信号

- 解决调用exit函数退出时局部对象没有调用析构函数的问题

  在写文件的时候会创建一个临时文件，写完之后会将临时文件的名字命名为正式的文件名，若在写文件的过程中，程序突然退出，则需要将这个未完成的临时文件删除，若将CFile类定义到局部，则不会调用析构函数来删除这个未完成的临时文件，所以需要将CFile声明为全局的。

- 把心跳信息写入共享内存，让守护进程来监控生成测试数据的程序

**生成测试数据的程序运行时间非常快，还没来得及接收信号就运行完毕了，一般不会挂掉，所以不需要维护心跳信息，但我们还是给此程序加上来练习。**

## 压缩文件

将指定时间之前的历史文件进行压缩处理

```c++
while(true)
  {
    // 得到一个文件的信息，CDir.ReadDir()
    if (Dir.ReadDir()==false)
    break;

    // printf("FullFileName=%s\n",Dir.m_FullFileName);

    // 与超时的时间点进行比较，如果更早，就需要压缩
    if (strcmp(Dir.m_ModifyTime,strTimeOut)<0&&(MatchStr(Dir.m_FileName,"*.gz")==false))
    {
      int tmp; // 记录execl的返回值，判断是否执行成功
      // 压缩文件，调用操作系统的gzip命令
      if(fork()==0)
      {
        tmp=execl("/usr/bin/gzip","/usr/bin/gzip","-f",Dir.m_FullFileName,(char*)0);
      }
      else
      {
        signal(SIGCHLD,SIG_IGN);
        if(tmp==-1)
        printf("gzip %s faile.\n",Dir.m_FullFileName);
        else
        printf("gzip %s ok.\n",Dir.m_FullFileName);
      }
    }
  }
```



## 清理文件

与压缩文件的实现方法基本相同，只需将最后调用gzip命令改为调用REMOVE命令(系统提供的删除文件的函数是remove)。

## 服务程序的运行策略

使用shell脚本文件 

**如何在操作系统启动的时候把全部的服务程序运行起来：**

Linux有一个系统启动的脚本文件 /ect/rc.local
